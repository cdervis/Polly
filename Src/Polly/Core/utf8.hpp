// Copyright 2006-2016 Nemanja Trifunovic

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

// Modified for use in Polly.

#pragma once

#include "Polly/Logging.hpp"
#include "Polly/String.hpp"
#include <cstring>
#include <iterator>

namespace utf8
{
// Helper code - not intended to be directly called by the library users. May be changed at any time
namespace internal
{
// Unicode constants
// Leading (high) surrogates: 0xd800 - 0xdbff
// Trailing (low) surrogates: 0xdc00 - 0xdfff
constexpr char16_t lead_surrogate_min  = 0xd800u;
constexpr char16_t lead_surrogate_max  = 0xdbffu;
constexpr char16_t trail_surrogate_min = 0xdc00u;
constexpr char16_t trail_surrogate_max = 0xdfffu;
constexpr char16_t lead_offset         = 0xd7c0u; // LEAD_SURROGATE_MIN - (0x10000 >> 10)
constexpr char32_t surrogate_offset =
    0xfca02400u; // 0x10000u - (LEAD_SURROGATE_MIN << 10) - TRAIL_SURROGATE_MIN

// Maximum valid value for a Unicode code point
constexpr char32_t code_point_max = 0x0010ffffu;

template<typename OctetType>
char8_t Mask8(OctetType oc)
{
    return static_cast<char8_t>(0xff & oc);
}

template<typename U16Type>
char16_t mask16(U16Type oc)
{
    return static_cast<char16_t>(0xffff & oc);
}

template<typename OctetType>
bool is_trail(OctetType oc)
{
    return ((internal::Mask8(oc) >> 6) == 0x2);
}

inline bool is_lead_surrogate(char32_t cp)
{
    return (cp >= lead_surrogate_min && cp <= lead_surrogate_max);
}

inline bool is_trail_surrogate(char32_t cp)
{
    return (cp >= trail_surrogate_min && cp <= trail_surrogate_max);
}

inline bool is_surrogate(char32_t cp)
{
    return (cp >= lead_surrogate_min && cp <= trail_surrogate_max);
}

inline bool is_code_point_valid(char32_t cp)
{
    return (cp <= code_point_max && !is_surrogate(cp));
}

inline bool is_in_bmp(char32_t cp)
{
    return cp < char32_t(0x10000);
}

template<typename OctetIterator>
int sequence_length(OctetIterator lead_it)
{
    const char8_t lead = internal::Mask8(*lead_it);
    if (lead < 0x80)
        return 1;
    if ((lead >> 5) == 0x6)
        return 2;
    if ((lead >> 4) == 0xe)
        return 3;
    if ((lead >> 3) == 0x1e)
        return 4;

    return 0;
}

inline bool is_overlong_sequence(char32_t cp, int length)
{
    if (cp < 0x80)
    {
        if (length != 1)
        {
            return true;
        }
    }
    else if (cp < 0x800)
    {
        if (length != 2)
        {
            return true;
        }
    }
    else if (cp < 0x10000)
    {
        if (length != 3)
        {
            return true;
        }
    }
    return false;
}

enum utf_error
{
    UTF8_OK,
    NOT_ENOUGH_ROOM,
    INVALID_LEAD,
    INCOMPLETE_SEQUENCE,
    OVERLONG_SEQUENCE,
    INVALID_CODE_POINT
};

/// Helper for get_sequence_x
template<typename OctetIterator>
utf_error increase_safely(OctetIterator& it, const OctetIterator end)
{
    if (++it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    if (!internal::is_trail(*it))
    {
        return INCOMPLETE_SEQUENCE;
    }

    return UTF8_OK;
}

#define UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(IT, END)                                                       \
    {                                                                                                        \
        utf_error ret = increase_safely(IT, END);                                                            \
        if (ret != UTF8_OK)                                                                                  \
            return ret;                                                                                      \
    }

/// get_sequence_x functions decode utf-8 sequences of the length x
template<typename OctetIterator>
utf_error get_sequence_1(OctetIterator& it, OctetIterator end, char32_t& code_point)
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    code_point = internal::Mask8(*it);

    return UTF8_OK;
}

template<typename OctetIterator>
utf_error get_sequence_2(OctetIterator& it, OctetIterator end, char32_t& code_point)
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    code_point = internal::Mask8(*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point = ((code_point << 6) & 0x7ff) + ((*it) & 0x3f);

    return UTF8_OK;
}

template<typename OctetIterator>
utf_error get_sequence_3(OctetIterator& it, OctetIterator end, char32_t& code_point)
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    code_point = internal::Mask8(*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point = ((code_point << 12) & 0xffff) + ((internal::Mask8(*it) << 6) & 0xfff);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point += (*it) & 0x3f;

    return UTF8_OK;
}

template<typename OctetIterator>
utf_error get_sequence_4(OctetIterator& it, OctetIterator end, char32_t& code_point)
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    code_point = internal::Mask8(*it);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point = ((code_point << 18) & 0x1fffff) + ((internal::Mask8(*it) << 12) & 0x3ffff);

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point += (internal::Mask8(*it) << 6) & 0xfff;

    UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR(it, end)

    code_point += (*it) & 0x3f;

    return UTF8_OK;
}

#undef UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR

template<typename OctetIterator>
utf_error validate_next(OctetIterator& it, OctetIterator end, char32_t& code_point)
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }

    // Save the original value of it so we can go back in case of failure
    // Of course, it does not make much sense with i.e. stream iterators
    OctetIterator original_it = it;

    char32_t cp = 0;
    // Determine the sequence length based on the lead octet
    const int length = internal::sequence_length(it);

    // Get trail octets and calculate the code point
    utf_error err = UTF8_OK;
    switch (length)
    {
        case 0: return INVALID_LEAD;
        case 1: err = internal::get_sequence_1(it, end, cp); break;
        case 2: err = internal::get_sequence_2(it, end, cp); break;
        case 3: err = internal::get_sequence_3(it, end, cp); break;
        case 4: err = internal::get_sequence_4(it, end, cp); break;
        default: break;
    }

    if (err == UTF8_OK)
    {
        // Decoding succeeded. Now, security checks...
        if (is_code_point_valid(cp))
        {
            if (!is_overlong_sequence(cp, length))
            {
                // Passed! Return here.
                code_point = cp;
                ++it;
                return UTF8_OK;
            }

            err = OVERLONG_SEQUENCE;
        }
        else
        {
            err = INVALID_CODE_POINT;
        }
    }

    // Failure branch - restore the original value of the iterator
    it = original_it;

    return err;
}

template<typename OctetIterator>
utf_error validate_next(OctetIterator& it, OctetIterator end)
{
    char32_t ignored = 0;
    return internal::validate_next(it, end, ignored);
}

template<typename WordIterator>
utf_error validate_next16(WordIterator& it, WordIterator end, char32_t& code_point)
{
    if (it == end)
    {
        return NOT_ENOUGH_ROOM;
    }
    // Save the original value of it so we can go back in case of failure
    // Of course, it does not make much sense with i.e. stream iterators
    WordIterator original_it = it;

    utf_error err = UTF8_OK;

    const char16_t first_word = *it++;
    if (!is_surrogate(first_word))
    {
        code_point = first_word;
        return UTF8_OK;
    }

    if (it == end)
    {
        err = NOT_ENOUGH_ROOM;
    }
    else if (is_lead_surrogate(first_word))
    {
        const char16_t second_word = *it++;
        if (is_trail_surrogate(second_word))
        {
            code_point = (first_word << 10) + second_word + surrogate_offset;
            return UTF8_OK;
        }

        err = INCOMPLETE_SEQUENCE;
    }
    else
    {
        err = INVALID_LEAD;
    }

    // error branch
    it = original_it;

    return err;
}
} // namespace internal

/// The library API - functions intended to be called by the users

// Byte order mark
constexpr char8_t bom[] = {0xef, 0xbb, 0xbf};

template<typename OctetIterator>
OctetIterator find_invalid(OctetIterator start, OctetIterator end)
{
    OctetIterator result = start;

    while (result != end)
    {
        if (internal::validate_next(result, end) != internal::UTF8_OK)
        {
            return result;
        }
    }

    return result;
}

inline const char* find_invalid(const char* str)
{
    const char* end = str + std::strlen(str);
    return find_invalid(str, end);
}

inline std::size_t find_invalid(const Polly::String& s)
{
    const auto invalid = find_invalid(s.begin(), s.end());
    return (invalid == s.end()) ? static_cast<size_t>(-1) : static_cast<std::size_t>(invalid - s.begin());
}

template<typename OctetIterator>
inline bool is_valid(OctetIterator start, OctetIterator end)
{
    return (utf8::find_invalid(start, end) == end);
}

inline bool is_valid(const char* str)
{
    return (*(find_invalid(str)) == '\0');
}

inline bool is_valid(const Polly::String& s)
{
    return is_valid(s.begin(), s.end());
}

template<typename OctetIterator>
bool starts_with_bom(OctetIterator it, OctetIterator end)
{
    return (
        ((it != end) && (internal::Mask8(*it++)) == bom[0])
        && ((it != end) && (internal::Mask8(*it++)) == bom[1])
        && ((it != end) && (internal::Mask8(*it)) == bom[2]));
}

inline bool starts_with_bom(const Polly::String& s)
{
    return starts_with_bom(s.begin(), s.end());
}

/// The library API - functions intended to be called by the users

template<typename OctetIterator>
char32_t next(OctetIterator& it, OctetIterator end)
{
    char32_t cp = 0;
    switch (internal::validate_next(it, end, cp))
    {
        case internal::UTF8_OK: break;
        case internal::NOT_ENOUGH_ROOM: throw Polly::Error("utf8: Not enough room");
        case internal::INVALID_LEAD:
        case internal::INCOMPLETE_SEQUENCE:
        case internal::OVERLONG_SEQUENCE: throw Polly::Error("utf8: Invalid UTF-8");
        case internal::INVALID_CODE_POINT: throw Polly::Error("utf8: Invalid code point");
        default: break;
    }
    return cp;
}

template<typename word_iterator>
char32_t next16(word_iterator& it, word_iterator end)
{
    char32_t cp       = 0;
    auto     err_code = internal::validate_next16(it, end, cp);

    if (err_code == internal::NOT_ENOUGH_ROOM)
    {
        throw Polly::Error("utf8: not enough room");
    }

    return cp;
}

template<typename OctetIterator>
char32_t peek_next(OctetIterator it, OctetIterator end)
{
    return utf8::next(it, end);
}

template<typename OctetIterator>
char32_t prior(OctetIterator& it, OctetIterator start)
{
    // can't do much if it == start
    if (it == start)
    {
        throw Polly::Error("utf8: not enough room");
    }

    OctetIterator end = it;

    // Go back until we hit either a lead octet or start
    while (internal::is_trail(*(--it)))
    {
        if (it == start)
        {
            // throw invalid_utf8( *it ); // error - no lead byte in the sequence
            return 0;
        }
    }

    return utf8::peek_next(it, end);
}

template<typename OctetIterator, typename distance_type>
void advance(OctetIterator& it, distance_type n, OctetIterator end)
{
    const distance_type zero(0);
    if (n < zero)
    {
        // backward
        for (distance_type i = n; i < zero; ++i)
        {
            utf8::prior(it, end);
        }
    }
    else
    {
        // forward
        for (distance_type i = zero; i < n; ++i)
        {
            utf8::next(it, end);
        }
    }
}

template<typename OctetIterator>
typename std::iterator_traits<OctetIterator>::difference_type distance(
    OctetIterator first,
    OctetIterator last)
{
    typename std::iterator_traits<OctetIterator>::difference_type dist;
    for (dist = 0; first < last; ++dist)
    {
        utf8::next(first, last);
    }
    return dist;
}

// The iterator class
template<typename OctetIterator>
class iterator
{
    OctetIterator it;
    OctetIterator range_start;
    OctetIterator range_end;

  public:
    using value_type        = char32_t;
    using pointer           = char32_t*;
    using reference         = char32_t&;
    using difference_type   = std::ptrdiff_t;
    using iterator_category = std::bidirectional_iterator_tag;

    iterator() = default;

    explicit iterator(
        const OctetIterator& octetIt,
        const OctetIterator& rangestart,
        const OctetIterator& rangeend)
        : it(octetIt)
        , range_start(rangestart)
        , range_end(rangeend)
    {
        if (it < range_start || it > range_end)
        {
            throw Polly::Error("Invalid utf-8 iterator position");
        }
    }
    // the default "big three" are OK
    OctetIterator base() const
    {
        return it;
    }
    char32_t operator*() const
    {
        OctetIterator temp = it;
        return utf8::next(temp, range_end);
    }
    bool operator==(const iterator& rhs) const
    {
        if (range_start != rhs.range_start || range_end != rhs.range_end)
        {
            throw Polly::Error("Comparing utf-8 iterators defined with different ranges");
        }
        return (it == rhs.it);
    }
    bool operator!=(const iterator& rhs) const
    {
        return !(operator==(rhs));
    }
    iterator& operator++()
    {
        utf8::next(it, range_end);
        return *this;
    }
    iterator operator++(int)
    {
        iterator temp = *this;
        utf8::next(it, range_end);
        return temp;
    }
    iterator& operator--()
    {
        utf8::prior(it, range_start);
        return *this;
    }
    iterator operator--(int)
    {
        iterator temp = *this;
        utf8::prior(it, range_start);
        return temp;
    }
}; // class iterator
} // namespace utf8
